<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>비트마스크 - Tag - JYUKKI&#39;s BLOG</title>
        <link>https://jyukki97.github.io/tags/%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC/</link>
        <description>비트마스크 - Tag - JYUKKI&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 18 Apr 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jyukki97.github.io/tags/%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC/" rel="self" type="application/rss+xml" /><item>
    <title>[백준]3056 007</title>
    <link>https://jyukki97.github.io/2020-04-18-3056/</link>
    <pubDate>Sat, 18 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-18-3056/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/3056
풀이: d[x] : 비트마스크가 x인 미션을 완료 할 확률
비트마스크 x : 나누어 준 미션은 1, 아직 나누어 주지 않은 미션은 0
비트마스크가 1, 10, 100, 1000 &hellip;.. 등 1의 갯수가 1개인 것은 첫 번째 지미 본드가 수행한다고 한다.
비트마스크가 11, 110, 1100, 11000 &hellip;.. 등 1의 갯수가 2개인 것은 두 번째 지미 본드가 수행한다고 한다.
&hellip;.
비트마스크를 0 ~ (1 &laquo; n) 까지 순회한다.
현재의 비트마스크를 i 라고 하자, 그 비트의 중간에 0이 들어있다면, 그 위치에 1을 넣는다.]]></description>
</item><item>
    <title>[백준]1102 발전소</title>
    <link>https://jyukki97.github.io/2020-04-17-1102/</link>
    <pubDate>Fri, 17 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-04-17-1102/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/1102
풀이: 발전소의 현재 상태를 2진수로 표현한다.
ex) YNN -&gt; 100
l : 발전소의 현재 상태를 2진수로 표현한 값
z : 발전소가 현재 켜져있는 갯수
z가 p보다 크거나 같아진다면 반복을 종료한다.
d[x] : x상태인 발전소를 만드는데 필요한 비용
d[x] = min(d[x], B(x | (1&laquo;y), z + 1) + a[u][y])
현재 발전소의 상태에서 안켜진 부분을 키되, 가장 적은 비용으로 킨 후 z를 + 1 한다.
p값이 0이라면 발전소를 킬 필요가 없으므로 0을 출력]]></description>
</item><item>
    <title>[백준]11723 집합</title>
    <link>https://jyukki97.github.io/2020-03-04-11723/</link>
    <pubDate>Wed, 04 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-03-04-11723/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/11723
풀이: [C++]비트연산자 참고
add : or 연산을 통해 값을 추가한다.
remove : 값이 있는지 확인 후 있다면, xor 연산으로 삭제한다.
check : 값이 있는지 and 연산으로 확인 후 있다면 1, 없다면 0을 출력한다.
toggle : 값이 있다면 삭제하고, 없다면 추가한다.
all : 비트값을 (2^20) - 1 로 바꿔주어, 1 ~ 20 까지 채워놓는다.
empty : 비트값을 0으로 바꿔주어, 공집합으로 만들어놓는다.
시간제한이있으므로 비트마스크를 통해 연산하도록한다. cin, cout 을 사용할 경우 시간초과가 나므로 주의하자.]]></description>
</item><item>
    <title>[C&#43;&#43;]비트연산자</title>
    <link>https://jyukki97.github.io/2020-02-28-bitoperator/</link>
    <pubDate>Fri, 28 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2020-02-28-bitoperator/</guid>
    <description><![CDATA[비트연산자
비트연산자 DP문제를 푸는데 있어, 연산속도를 빠르게 하기 위해 사용 &laquo; , &raquo; 시프트 연산자. 비트의 자리를 옮겨줌 ex)
1 &laquo; 3
 1000
 NOT - ( ~ ) 0 은 1로 1은 0으로 반대로 바꿔준다. ex)
0000000
 1111111
 AND - ( &amp; ) 둘 다 1 일때만 1, 아니면 0 ex)
1100110
&amp; 1011001
 1000110
 OR - ( | ) 둘 중 하나라도 1이라면 1, 아니면 0 ex)]]></description>
</item><item>
    <title>[백준]2718 타일 채우기</title>
    <link>https://jyukki97.github.io/2017-12-16-2718/</link>
    <pubDate>Sat, 16 Dec 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jyukki97.github.io/2017-12-16-2718/</guid>
    <description><![CDATA[https://www.acmicpc.net/problem/2718
풀이:  a[t] 는 4 x t 크기의 타일을 채울 수 있는 경우의 수 a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4];  코드: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; int a[30] = { 1,5,11,36 }; int main(void) { int T,n,cnt; cnt = 5; cin &gt;&gt; T; for (int i = 0; i &lt; T; i++) { cin &gt;&gt; n; if (a[n - 1] == 0) for (int t = cnt-1; t &lt; n; t++) { a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4]; } cout &lt;&lt; a[n - 1] &lt;&lt; endl; cnt = max(cnt, n); } return 0; }   ]]></description>
</item></channel>
</rss>
